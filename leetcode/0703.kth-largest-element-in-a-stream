You are part of a university admissions office and need to keep track of the kth highest test score from applicants in real-time. This helps to determine cut-off marks for interviews and admissions dynamically as new applicants submit their scores.

You are tasked to implement a class which, for a given integer k, maintains a stream of test scores and continuously returns the kth highest test score after a new score has been submitted. More specifically, we are looking for the kth highest score in the sorted list of all scores.

Implement the KthLargest class:

KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of test scores nums.
int add(int val) Adds a new test score val to the stream and returns the element representing the kth largest element in the pool of test scores so far.
 

Example 1:

Input:
["KthLargest", "add", "add", "add", "add", "add"]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]

Output: [null, 4, 5, 5, 8, 8]

Explanation:

KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3); // return 4
kthLargest.add(5); // return 5
kthLargest.add(10); // return 5
kthLargest.add(9); // return 8
kthLargest.add(4); // return 8

Example 2:

Input:
["KthLargest", "add", "add", "add", "add"]
[[4, [7, 7, 7, 7, 8, 3]], [2], [10], [9], [9]]

Output: [null, 7, 7, 7, 8]

Explanation:

KthLargest kthLargest = new KthLargest(4, [7, 7, 7, 7, 8, 3]);
kthLargest.add(2); // return 7
kthLargest.add(10); // return 7
kthLargest.add(9); // return 7
kthLargest.add(9); // return 8
 

Constraints:
0 <= nums.length <= 10^4
1 <= k <= nums.length + 1
-10^4 <= nums[i] <= 10^4
-10^4 <= val <= 10^4
At most 10^4 calls will be made to add.

### MinHeap Solution
```ts
class MinHeap1 {
  private heap: number[] = [];

  // Insert a new value into the heap
  insert(value: number): void {
    this.heap.push(value); // Add to end
    this.bubbleUp();       // Restore heap property by moving up
  }

  // Remove and return the minimum element (root)
  extractMin(): number | undefined {
    if (this.size() === 0) return undefined; // Empty case
    if (this.size() === 1) return this.heap.pop(); // Single element

    const min = this.heap[0]; // Save root (min value)
    this.heap[0] = this.heap.pop()!; // Move last element to root
    this.bubbleDown(); // Restore heap property by moving down
    return min;
  }

  // Return the minimum element without removing it
  peek(): number | undefined {
    return this.heap[0];
  }

  // Get current number of elements
  size(): number {
    return this.heap.length;
  }

  // Check if heap has no elements
  isEmpty(): boolean {
    return this.size() === 0;
  }

  // Move newly inserted element up to correct position
  private bubbleUp(): void {
    let index = this.heap.length - 1; // Start at last element

    // While not at root (index > 0)
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2); // Parent formula

      // If parent â‰¤ current, heap property is satisfied
      if (this.heap[parentIndex] <= this.heap[index]) break;

      // Swap with parent to restore order
      this.swap(index, parentIndex);

      // Move up to parent's position
      index = parentIndex;
    }
  }

  // Move root element down to correct position after extraction
  private bubbleDown(): void {
    let index = 0; // Start at root
    const length = this.heap.length;

    while (true) {
      let smallest = index; // Assume current is smallest
      const left = 2 * index + 1;   // Left child index
      const right = 2 * index + 2;  // Right child index

      // Check if left child exists and is smaller
      if (left < length && this.heap[left] < this.heap[smallest]) {
        smallest = left;
      }

      // Check if right child exists and is smaller than current smallest
      if (right < length && this.heap[right] < this.heap[smallest]) {
        smallest = right;
      }

      // If current is already smallest, heap property is restored
      if (smallest === index) break;

      // Swap with the smaller child
      this.swap(index, smallest);

      // Continue from the child's position
      index = smallest;
    }
  }

  // Helper to swap two elements in the heap array
  private swap(i: number, j: number): void {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }
}

class KthLargest {
    private k: number;
    private heap: MinHeap1;

    constructor(k: number, nums: number[]) {
        this.k = k;
        this.heap = new MinHeap1();

        for(const num of nums) {
            this.heap.insert(num);
        }

        while(this.heap.size() > k) {
            this.heap.extractMin();
        }
    }

    add(val: number): number {
        this.heap.insert(val);

        if(this.heap.size() > this.k) {
            this.heap.extractMin();
        }

        return this.heap.peek()
    }
}

/**
 * Your KthLargest object will be instantiated and called as such:
 * var obj = new KthLargest(k, nums)
 * var param_1 = obj.add(val)
 */
```
